local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local TextChatService = game:GetService("TextChatService")
local generalChannel = TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXGeneral")


local player = Players.LocalPlayer

local muteEnabled = false
local activeSounds = {}

local isEnabled = false
local loadedScriptModel


-- Global version variable
_G.version = "v0.27"

local function createVersionLabel()
	local gui = Instance.new("ScreenGui")
	gui.Name = "VersionGui"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.Parent = player:WaitForChild("PlayerGui")

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(0, 100, 0, 20)
	label.Position = UDim2.new(0.5, -50, 1, -30) -- Center bottom
	label.AnchorPoint = Vector2.new(0, 0)
	label.BackgroundTransparency = 1
	label.Text = _G.version
	label.TextColor3 = Color3.new(1, 1, 1)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSans
	label.Parent = gui
end

local function sendChatMessage(message)
    if typeof(message) == "string" and message ~= "" then
        local symbols = {"!", "?", "@", "#", "$", "%", "&"}
        local words = {}

        -- Split the message into words
        for word in message:gmatch("%S+") do
            table.insert(words, word)
        end

        -- Rebuild message with random symbols between words
        local randomizedMessage = ""
        for i, word in ipairs(words) do
            randomizedMessage = randomizedMessage .. word
            if i < #words then
                -- Add a random symbol + a space
                randomizedMessage = randomizedMessage .. symbols[math.random(#symbols)] .. " "
            end
        end

        generalChannel:SendAsync(randomizedMessage)
        print("Sent message: " .. randomizedMessage)
    end
end


local function stopAllSoundsOnMute()
    for i = #activeSounds, 1, -1 do
        local entry = activeSounds[i]
        local s = entry.sound
        if s and s:IsA("Sound") and s:IsDescendantOf(game) then
            entry.offset = s.TimePosition
            s:Stop()
        else
            table.remove(activeSounds, i)
        end
    end
end



local function createAudioButton()
	local gui = Instance.new("ScreenGui")
	gui.Name = "AudioGui"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.Parent = player:WaitForChild("PlayerGui")

	local button = Instance.new("TextButton")
	button.Size = UDim2.new(0, 100, 0, 40)
	button.Position = UDim2.new(1, -110, 0, 10)
	button.AnchorPoint = Vector2.new(0, 0)
	button.Text = "mute: OFF"
	button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
	button.TextColor3 = Color3.new(1, 1, 1)
	button.TextScaled = true
	button.Parent = gui

	local sound = Instance.new("Sound")
	sound.Name = "BackgroundSound"
	sound.Looped = true
	sound.Volume = 1
	sound.Parent = game:GetService("SoundService")

	

	button.MouseButton1Click:Connect(function()
        muteEnabled = not muteEnabled
    
        if muteEnabled then
            button.Text = "mute: ON"
            button.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    
            for i = #activeSounds, 1, -1 do
                local entry = activeSounds[i]
                local s = entry.sound
                if s and s:IsA("Sound") and s:IsDescendantOf(game) then
                    entry.offset = s.TimePosition
                    s:Stop()
                else
                    table.remove(activeSounds, i)
                end
            end
    
        else
            button.Text = "mute: OFF"
            button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    
            for i = #activeSounds, 1, -1 do
                local entry = activeSounds[i]
    
                local resumed = Instance.new("Sound")
                resumed.SoundId = "rbxassetid://" .. entry.id
                resumed.Volume = entry.volume
                resumed.TimePosition = entry.offset
                resumed.Parent = game:GetService("SoundService")
    
                -- Replace old sound ref
                entry.sound = resumed
                entry.startTick = tick()
    
                resumed.Ended:Connect(entry.onEnded)
                resumed:Play()
            end
        end
    end)
end

-- Utility: Show bottom-right notification
local function showBottomRightNotification(message)
    StarterGui:SetCore("SendNotification", {
        Title = "Warning",
        Text = message,
        Duration = 5
    })
end

-- Show "It refused" popup 3s after death, lasts 2s
local function showItRefused()
    task.delay(3, function()
        local gui = Instance.new("ScreenGui")
        gui.Name = "RefusedPopup"
        gui.ResetOnSpawn = false
        gui.Parent = player:WaitForChild("PlayerGui")

        local text = Instance.new("TextLabel")
        text.Size = UDim2.new(0.3, 0, 0.1, 0)
        text.Position = UDim2.new(0.35, 0, 0.4, 0)
        text.BackgroundTransparency = 1
        text.Text = "It refused"
        text.TextColor3 = Color3.new(1, 1, 0)
        text.Font = Enum.Font.SourceSansBold
        text.TextScaled = true
        text.Parent = gui

        task.delay(2, function()
            gui:Destroy()
        end)
    end)
end

-- Create toggle button on screen top-right
local function createToggleButton()
    local gui = player:WaitForChild("PlayerGui"):FindFirstChild("ToggleGui")
    if gui then gui:Destroy() end

    gui = Instance.new("ScreenGui")
    gui.Name = "ToggleGui"
    gui.ResetOnSpawn = false
    gui.Parent = player:WaitForChild("PlayerGui")

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 120, 0, 30)
    button.Position = UDim2.new(1, -130, 0, 10)
    button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    button.TextColor3 = Color3.new(1, 1, 1)
    button.Font = Enum.Font.SourceSansBold
    button.TextSize = 18
    button.Text = "Script: ON"
    button.Parent = gui

    button.MouseButton1Click:Connect(function()
        isEnabled = not isEnabled
        button.Text = isEnabled and "Script: ON" or "Script: OFF"
        showBottomRightNotification("Script is now " .. (isEnabled and "ENABLED" or "DISABLED"))
    end)
end

-- Stop all currently playing sounds
local function stopAllSounds()
    for _, sound in ipairs(game:GetDescendants()) do
        if sound:IsA("Sound") then
            sound:Stop()
        end
    end
end

-- Block and delete sounds for a given duration (deletes existing sounds + blocks new ones)
local function blockAndDeleteSoundsFor(duration, excludeList)
    -- Helper function to check if a SoundId is excluded
    local function isExcluded(soundId)
        for _, excludedId in ipairs(excludeList) do
            if string.find(soundId, excludedId) then
                return true
            end
        end
        return false
    end

    -- Delete all existing sounds unless they're in the exclude list
    for _, sound in pairs(game:GetDescendants()) do
        if sound:IsA("Sound") and not isExcluded(sound.SoundId) then
            sound:Destroy()
        end
    end

    local blocked = true
    local connection = game.DescendantAdded:Connect(function(descendant)
        if blocked and descendant:IsA("Sound") and not isExcluded(descendant.SoundId) then
            descendant:Destroy()
        end
    end)

    task.wait(duration)

    blocked = false
    connection:Disconnect()
end

-- Set noclip by toggling CanCollide on character parts
local function setNoclip(character, enabled)
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            part.CanCollide = not enabled
        end
    end
end

-- Cleanup BodyMovers from HumanoidRootPart
local function cleanupBodyMovers(hrp)
    for _, child in pairs(hrp:GetChildren()) do
        if child:IsA("BodyPosition") or child:IsA("BodyGyro") then
            child:Destroy()
        end
    end
end

-- Make character lie flat and float up smoothly
local function LieFlatAndFloat(character, hrp, humanoid, floatHeight, floatDuration)
    floatHeight = floatHeight or 8
    floatDuration = floatDuration or 3

    humanoid.PlatformStand = true
    setNoclip(character, true)
    cleanupBodyMovers(hrp)

    -- Lie flat on back
    hrp.CFrame = hrp.CFrame * CFrame.Angles(math.rad(90), 0, 0)

    wait(2) -- duration lying flat

    cleanupBodyMovers(hrp)

    local startPos = hrp.Position
    local targetPos = startPos + Vector3.new(0, floatHeight, 0)
    local currentYRotation = hrp.Orientation.Y
    local targetCFrame = CFrame.new(targetPos) * CFrame.Angles(0, math.rad(currentYRotation), 0)

    local bodyPos = Instance.new("BodyPosition")
    bodyPos.MaxForce = Vector3.new(1e5, 1e5, 1e5)
    bodyPos.Position = startPos
    bodyPos.Parent = hrp

    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bodyGyro.CFrame = hrp.CFrame
    bodyGyro.Parent = hrp

    local elapsed = 0
    local connection
    connection = RunService.Heartbeat:Connect(function(dt)
        elapsed = elapsed + dt
        local alpha = math.clamp(elapsed / floatDuration, 0, 1)

        local newPos = startPos:Lerp(targetPos, alpha)
        local startRot = hrp.CFrame - startPos
        local targetRot = targetCFrame - targetPos
        local newRot = CFrame.new(Vector3.new()):Lerp(targetRot, alpha)

        bodyPos.Position = newPos
        bodyGyro.CFrame = CFrame.new(newPos) * newRot

        if alpha >= 1 then
            connection:Disconnect()
        end
    end)

    wait(floatDuration + 3) -- Float duration + extra hold time

    humanoid.PlatformStand = false
    setNoclip(character, false)
    cleanupBodyMovers(hrp)
end

local function playSFX(id, volume)
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://" .. tostring(id)
	sound.Volume = volume or 1
	sound.Parent = game:GetService("SoundService")
	sound:Play()

	sound.Ended:Connect(function()
		sound:Destroy()
	end)
end
	

local function playSFXList(ids, volume)
    if not ids or #ids == 0 then return end

    local index = 1

    local function playNext()
        if index > #ids then return end

        local id = tostring(ids[index])
        local sound = Instance.new("Sound")
        sound.SoundId = "rbxassetid://" .. id
        sound.Volume = muteEnabled and 0 or (volume or 1)
        sound.TimePosition = 0
        sound.Parent = game:GetService("SoundService")

        local data = {
            sound = sound,
            id = id,
            volume = volume or 1,
            startTick = tick(),
            offset = 0,
            onEnded = function()
                -- Clean up
                for i, s in ipairs(activeSounds) do
                    if s.sound == sound  then
                        table.remove(activeSounds, i)
                        break
                    end
                end
                index = index + 1
                playNext()
            end
        }

        table.insert(activeSounds, data)

        sound.Ended:Connect(data.onEnded)
        sound:Play()
    end

    playNext()
end

local function playRandomSFXEvery10Seconds(...)
	local soundData = {...}
	local player = Players.LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local hrp = character:WaitForChild("HumanoidRootPart")

	task.spawn(function()
		while true do
			task.wait(15 + math.random()) -- ~10 seconds with slight randomness

			if #soundData > 0 then
				local randomEntry = soundData[math.random(1, #soundData)]
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://" .. tostring(randomEntry.SoundId)
				sound.Parent = hrp
				sound.Volume = 1
				sound:Play()

				-- Run action if present and a function
				if randomEntry.Action and typeof(randomEntry.Action) == "function" then
					randomEntry.Action()
				end

				sound.Ended:Connect(function()
					sound:Destroy()
				end)
			end
		end
	end)
end



-- Main onSpawn handler
local function onSpawn(character)
    createToggleButton()
    createAudioButton()
    createVersionLabel()
    stopAllSounds()

    local humanoid = character:WaitForChild("Humanoid")
    local hrp = character:WaitForChild("HumanoidRootPart")

    humanoid.Died:Connect(function()
        
        sendChatMessage("how can this be...")
        showItRefused()
        playSFX(138653824465794,2)
        stopAllSoundsOnMute()
    end
    )

    if isEnabled then
        if humanoid.RigType == Enum.HumanoidRigType.R15 then
            showBottomRightNotification("R15 avatar detected. Script blocked.")
            return
        end

        loadedScriptModel = Instance.new("Folder")
        loadedScriptModel.Name = "LoadedScriptContainer"
        loadedScriptModel.Parent = workspace

        local env = setmetatable({}, { __index = getfenv() })
        env.workspace = loadedScriptModel
        wait(1.5)
        -- Run LieFlatAndFloat async
        task.spawn(function()
            LieFlatAndFloat(character, hrp, humanoid, 20, 5)
            task.wait(2)
            sendChatMessage("god is calling...")
        end)

        wait(5)

        -- Block sounds while loading and running external script
        if not muteEnabled then
            task.spawn(function()
                blockAndDeleteSoundsFor(5,{
                    "rbxassetid://14145625743" , 
                    "rbxassetid://80650419746306",
                    "rbxassetid://1837276045",
                    "rbxassetid://138653824465794"
                })
                
            end)
        end

        task.wait(0.5) -- allow blocker to start

        task.spawn(function()
            
            
            
            setfenv(loadstring(game:HttpGet('https://glot.io/snippets/gua2ntmbdm/raw/main.lua', true)), env)()
        end)
        wait(2)
        playSFXList({1837276045,14145625743,80650419746306},0.8)
        sendChatMessage("i am gods will...")
        
        wait(1)
        playRandomSFXEvery10Seconds(
	{SoundId = 104909608685735, Action = function() sendChatMessage("You defy the light...") end},
	{SoundId = 86385138656281, Action = function() sendChatMessage("an IMPERFECTION to be cleansed...") end},
	{SoundId = 116042450036642, Action = function() sendChatMessage("youre an ERROR to be corrected..") end}
)
            
        
    end
end

player.CharacterAdded:Connect(onSpawn)
if player.Character then
    onSpawn(player.Character)
end